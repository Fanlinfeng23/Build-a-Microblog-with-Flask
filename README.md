# datalab 报告

姓名：范林峰

学号：2023200424

| 总分  | bitXor | logtwo | byteSwap | reverse | logicalShift | leftBitCount | float_i2f | floatScale2 | float64_f2i | floatPower2 |
|-------|--------|--------|----------|---------|--------------|--------------|-----------|-------------|-------------|-------------|
| 36/36 | 1/1    | 2/2    | 4/4      | 4/4     | 3/3          | 3/3          | 4/4       | 4/4         | 3/3         | 4/4         |



test 截图：

![image](./imgs/image.png)

<!-- TODO: 用一个通过的截图，本地图片，放到 imgs 文件夹下，不要用这个 github，pandoc 解析可能有问题 -->

## 解题报告

### 亮点

<!-- 告诉助教哪些函数是你实现得最优秀的，比如你可以排序。不需要展开，展开请放到后文中。 -->

1. bitXor
2. byteSwap

### bitXor

```c
int bitXor(int x, int y) {
    return (~(x & y)) & (~((~x) & (~y)));
}
```

题目思路


1. 先分析XOR (异或) 的逻辑：
异或运算符 ^ 的特点是：只有当两个二进制位不同（一个是 0，一个是 1）时结果才为 1。
也就是说：x ^ y = (x 或 y 为 1，但不能同时为 1)。

2. 转化成合法运算符：
根据题目要求，使用 ~（按位取反）和 &（按位与）来模拟 ^。

3. 逻辑表达式拆解：
考虑~(x & y)：当 x 和 y 的位同时为 1 时，取反后变成 0。
相反地，~(~x & ~y)：当 x 和 y 的位同时为 0 时，取反后变成 0。
两者的 & 结果就是 XOR 的结果。

### samesign
```c
int samesign(int x, int y) {
    if ((!((x ^ y) >> 31))  && x && y) return 1;
    if ((!x) && (!y)) return 1;
    else return 0;
    
}
```
解题思路

1. 首先进行符号位的判断：
一个整数的符号位在二进制表示的最高位（第 31 位），0 表示非负数，1 表示负数。

2. x ^ y 的符号异或：
在x ^ y过程中，主要关注符号位：符号不同时，最高位为 1；符号相同时，最高位为 0。

3. (x ^ y) >> 31：移位后，结果为 1（不同符号）或 0（相同符号）。另外，由于0的符号位和正数相同，我们要排除0和正数进行比较的情况，所以在后面加入 &x &y 。如果有一个数为0，则不返回1.

4. 处理 0 的情况：
如果 x 和 y 都是 0，则结果为同号。




### logtwo
```c
int logtwo(int v) {
    int x = ((v >> 16) > 0) << 4;
    v = v >> x;
    
    int shift = ((v >> 8) > 0) << 3;
    v = v >> shift;
    x = x|shift;


    shift = ((v >> 4) > 0) << 2;
    v = v >> shift;
    x = x|shift;
    
    shift = ((v >> 2) > 0) << 1;
    v = v >> shift;
    x = x|shift;
    
    shift = ((v >> 1) > 0) << 0;
    v = v >> shift;
    x = x|shift;
    
    
    return x;
}
```
解题思路

1. 首先，根据题目要求的运算规律，我们求的logtwo即为寻找二进制的最高非零位（不考虑负数）。例如，32 = 2^5，因此其 log2 为 5。

2. 采取逐步移位判断：
由于没有循环，我们采取2的n次幂唯一的方式来寻找准确值。
首先将 v 右移 16 位，检查高 16 位是否有 1，如果有，将 x 加 16。
接下来继续移位（8、4、2、1），逐步找到最高位的准确位置。

3. 对结果取｜或：
由于我们每次得到的shift值都是在只有第n-1位上可能为1，想要把他们相加，只需取或即可。
这种实现方式避免了循环，通过移位高效计算二进制对数。

### byteswap
```c
int byteSwap(int x, int n, int m) {
    n = n << 3;
    m = m << 3;
    int y = ((x >> n ) & 0xFF) << m;
    int z = ((x >> m ) & 0xFF) << n;
    x = x & (~(0xFF << n));
    x = x & (~(0xFF << m));
    return x | y | z;
}
```
解题思路

1. 由于题目要求按字节进行提取，所以我们要先将m，n各自乘以8，得到新的m，n。

2. 提取字节：
使用 (x >> n) & 0xFF 提取第 n 个字节，m同理。即可得到m，n所在的各自八位的字节。

3. 清空原始字节位置：
使用 ~(0xFF << n) 清除第 n 和 m 个字节。使其对应位置置0.

4.合并结果：
将交换后的字节与原始数据合并，对取出的m，n所在字节以及置零后的x取或操作，即可得到最终结果。
### reverse
```c
unsigned reverse(unsigned v) {
    unsigned a = (0xAAAAAAAA & v) >> 1;
    unsigned b = (0x55555555 & v) << 1;
    v = a | b;
    a = (0xCCCCCCCC & v) >> 2;
    b = (0x33333333 & v) << 2;
    v = a | b;
    a = (0xF0F0F0F0 & v) >> 4;
    b = (0x0F0F0F0F & v) << 4;
    v = a | b;
    a = (0xFF00FF00 & v) >> 8; 
    b = (0x00FF00FF & v) << 8;
    v = a | b;
    a = (0xFFFF0000 & v) >> 16;
    b = (0x0000FFFF & v) << 16;
    v = a | b;
    
    return v;
}
```
解题思路

1. 基本思路：逐步交换相邻位：

(1)按位分组处理：这段代码逐步对 32 位整数中的位进行交换，从最低位到最高位，采用“分治法”逐步交换越来越大的位组。这步的主要意图就是先两两对换，再四四对换...保证每次对换后，在小范围内都会实现了反转，最后逐步扩展到32位。

(2)分解掩码逻辑：每次使用特定的掩码与输入进行按位与（&），然后分别左移或右移后通过按位或（|）合并。
0xAAAAAAAA 是一个交替出现 1 和 0 的掩码：101010...
0xCCCCCCCC 是两个相邻 1 后跟两个 0：11001100...
其他掩码以此类推（每次掩码覆盖的位数加倍）。

2. 第一步：交换相邻的位
代码：
```c
v = ((v & 0xAAAAAAAA) >> 1) | ((v & 0x55555555) << 1);
```
目的：将奇数位和偶数位进行交换。
将 0xAAAAAAAA 和 v 进行按位与，提取所有奇数位，然后将它们右移 1 位。
将 0x55555555 和 v 进行按位与，提取所有偶数位，然后将它们左移 1 位。
最后合并两部分，实现奇偶位交换。
3. 第二步：每 2 位一组进行交换
代码：
```c
v = ((v & 0xCCCCCCCC) >> 2) | ((v & 0x33333333) << 2);
```
目的：每两位为一组进行交换。
使用 0xCCCCCCCC 提取高两位，然后右移 2 位。
使用 0x33333333 提取低两位，然后左移 2 位。
合并后完成每 2 位的交换。
4. 第三步：每 4 位一组交换
代码：
```c
v = ((v & 0xF0F0F0F0) >> 4) | ((v & 0x0F0F0F0F) << 4);
```
目的：每 4 位为一组进行交换。
5. 第四步：每 8 位一组交换
代码：
```c
v = ((v & 0xFF00FF00) >> 8) | ((v & 0x00FF00FF) << 8);
```
6. 第五步：交换高 16 位和低 16 位
代码：
```c
return (v >> 16) | (v << 16);
```

### logicalshift
```c
int logicalShift(int x, int n) {
    int mask = ~(((1 << 31) >> n) << 1);  
    return (x >> n) & mask;  
}
```
解题思路

1. 针对该问题，在 C 中，右移操作符 >> 对有符号整数进行算术右移，即用符号位填充高位。如果要实现逻辑右移（用 0 填充高位），需要手动构造掩码来处理。

2. 构造掩码
```c
int mask = ~(((1 << 31) >> n) << 1);
```
1 << 31：将数字 1 左移 31 位，得到最高位为 1，其余位为 0 的二进制数。 
>> n：右移 n 位，产生一个右移后的高位掩码，前n+1位为1，后面全为0。
<< 1：再将掩码左移 1 位，对齐逻辑右移的效果。
这样做而非直接右移n-1位的目的是为了防止n=0时出现错误。
~：按位取反，得到逻辑右移所需的掩码。

3. 应用掩码
右移并与掩码相与：
```c
return (x >> n) & mask;
```
使用算术右移计算出的结果与掩码按位与，确保高位补 0，实现逻辑右移的效果。


### leftBitCount
```c
int leftBitCount(int x) {
    int y = x ^ 0xFFFFFFFF;
    int T = (!y) ;
    int a = (! (! (y >> 16))) << 4;
    y = y >> a;
    
    int b = (! (! (y >> 8))) <<3;
    y = y >> b;

    int c = (! (! (y >> 4))) <<2;
    y = y >> c;

    int d = (! (! (y >> 2))) <<1;
    y = y >> d;

    int e = (! (! (y >> 1))) <<0;
    y = y >> e;

    int bitcount = ((~(a|b|c|d|e)) ^ 32) & 0x0000001F;


    return (T<<5) | ((((!T)<<4)|((!T)<<3)|((!T)<<2)|((!T)<<1)|(!T))&bitcount) ;
}
```
解题思路：

1. 整体思路：
将输入 x 的二进制反转，变成找左侧连续 0的问题（即：将所有 1 翻转为 0，将所有 0 翻转为 1）。
通过逐层检查 16 位、8 位、4 位、2 位和 1 位，缩小范围，直到找到第一个非 0 位的位置。
最后使用位移和掩码计算总的连续 1 数。

2. 详细解题思路：
(1) 步骤 1：翻转所有位
```c
int y = x ^ 0xFFFFFFFF;
```
用 x ^ 0xFFFFFFFF 将 x 的所有位取反。
原问题是统计左侧连续 1 的数量，取反后等价于统计左侧连续 0 的数量。
(2) 步骤 2：检查 y 是否全为 0，排除特殊情况，二分只能查找1-31之间的数，故32时需要单独讨论。
```c
int T = (!y);
```
使用 !y 判断 y 是否为 0：
如果 y 为 0，说明原始的 x 中全是 1（即连续 1 的数量是 32），T = 1。
如果 y 非 0，则 T = 0，需要继续查找连续 1 的数量。

（3）步骤 3：逐步二分查找连续 0 的位置
第一级：检查高 16 位是否有非 0 位
```c
int a = (!(! (y >> 16))) << 4;
y = y >> a;
```
先将 y 右移 16 位，判断最高的 16 位是否全为 0：
如果全为 0，则结果为 0；否则为 1。
使用 (! (! ...)) 结构将结果强制转换为 0 或 1。
如果最高 16 位存在非 0 位，将 a 置为 16（即 1 << 4）。
接着将 y 右移 a 位，缩小搜索范围。

第二级：检查剩下的高 8 位
用类似逻辑检查接下来的 8、4、2、1 位，并根据结果决定是否再右移。

(4) 步骤 4：计算连续 1 的总数

```c
int bitcount = ((~(a | b | c | d | e)) ^ 32) & 0x0000001F;
```
a | b | c | d | e 表示在各级检查中右移的总位数。
~(...) ^ 32 用于计算连续 1 的数量：
由于我们统计的是连续 0 的数量，因此需要用 32 - (总位数) 得到连续 1 的数量。
& 0x0000001F 用于限制结果在 0 到 31 之间。

(5)步骤 5：处理特殊情况（全为 1 的情况）
```c
return (T << 5) | ((((!T) << 4) | ((!T) << 3) | ((!T) << 2) | ((!T) << 1) | (!T)) & bitcount);
```
判断是否全为 1：
如果 T = 1，说明原数 x 全是 1，此时结果直接是 32（T << 5）。
如果 T = 0，则返回计算的 bitcount。

###
```c

```

###
```c

```

###
```c

```

###
```c

```

###
```c

```

###
```c

```

###
```c

```

###
```c

```
## 反馈/收获/感悟/总结

<!-- 这一节，你可以简单描述你在这个 lab 上花费的时间/你认为的难度/你认为不合理的地方/你认为有趣的地方 -->

<!-- 或者是收获/感悟/总结 -->

<!-- 200 字以内，可以不写 -->

## 参考的重要资料

<!-- 有哪些文章/论文/PPT/课本对你的实现有重要启发或者帮助，或者是你直接引用了某个方法 -->

<!-- 请附上文章标题和可访问的网页路径 -->
